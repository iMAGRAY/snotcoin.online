'use client'

import React, { useCallback, useEffect, useRef, useState } from 'react'
import { GameStateContext, GameDispatchContext, IsSavingContext } from '../contexts'
import { gameReducer } from '../../../reducers/gameReducer'
import { createInitialGameState, Action, GameState, ExtendedGameState } from '../../../types/gameTypes'
import { 
  cleanupLocalStorage, 
  safeSetItem, 
  getLocalStorageSize 
} from '../../../services/localStorageManager'
import { SaveManager } from '../../../services/saveSystem/SaveManager'
import { StorageType, SavePriority } from '../../../services/saveSystem/types'
import { updateResourcesBasedOnTimePassed } from '../../../utils/resourceUtils'
import { getFillingSpeedByLevel } from '../../../utils/gameUtils'

interface GameProviderProps {
  children: React.ReactNode
  userId?: string
  enableAutoSave?: boolean
  autoSaveInterval?: number
}

/**
 * Нормализует userId, удаляя префикс если он есть
 * @param userId исходный userId
 * @returns нормализованный userId
 */
const normalizeUserId = (userId: string | undefined): string => {
  if (!userId) return '';
  
  // Удаляем префиксы, если они есть
  const prefixes = ['farcaster_', 'twitter_', 'github_', 'email_'];
  for (const prefix of prefixes) {
    if (userId.startsWith(prefix)) {
      return userId.substring(prefix.length);
    }
  }
  
  return userId;
};

// Переносим validateGameState и createDefaultGameState из gameDataService.ts
/**
 * Создает дефолтное состояние игры для случаев, когда валидация не удалась
 */
function createDefaultGameState(userId: string): GameState {
  return {
    _userId: userId, // Добавляем userId
    inventory: {
      snot: 0,
      snotCoins: 0,
      containerCapacity: 1, // Начальная вместимость контейнера - изменено с 5 на 1
      containerSnot: 0,
      fillingSpeed: 0.01, // Начальная скорость наполнения
      containerCapacityLevel: 1, // Начальный уровень вместимости
      fillingSpeedLevel: 1, // Начальный уровень скорости наполнения
      collectionEfficiency: 1, // Начальная эффективность сбора
      lastUpdateTimestamp: Date.now()
    },
    containers: [],
    resources: {
      water: 0
    },
    stats: {
      totalSnot: 0,
      totalSnotCoins: 0
    },
    _saveVersion: 1
  } as unknown as GameState;
}

/**
 * Функция для валидации игрового состояния
 * @param state Состояние для валидации
 * @returns Валидированное состояние
 */
function validateGameState(state: GameState): GameState {
  const validatedState = { ...state };

  // Проверяем основные поля
  if (!validatedState.inventory) {
    validatedState.inventory = {
      snot: 0,
      snotCoins: 0,
      containerSnot: 0,
      containerCapacity: 1,
      containerCapacityLevel: 1,
      fillingSpeed: 1,
      fillingSpeedLevel: 1,
      collectionEfficiency: 1.0,
      lastUpdateTimestamp: Date.now()
    };
  } else {
    // Валидируем поля инвентаря
    validatedState.inventory = {
      snot: Number(validatedState.inventory.snot || 0),
      snotCoins: Number(validatedState.inventory.snotCoins || 0),
      containerSnot: Number(validatedState.inventory.containerSnot || 0),
      containerCapacity: Number(validatedState.inventory.containerCapacity || 1),
      containerCapacityLevel: Number(validatedState.inventory.containerCapacityLevel || 1),
      fillingSpeed: Number(validatedState.inventory.fillingSpeed || 1),
      fillingSpeedLevel: Number(validatedState.inventory.fillingSpeedLevel || 1),
      collectionEfficiency: Number(validatedState.inventory.collectionEfficiency || 1),
      lastUpdateTimestamp: validatedState.inventory.lastUpdateTimestamp || Date.now()
    };
  }

  return validatedState;
}

// Функция для сравнения данных с экстренным сохранением  
const mergeWithEmergencySave = (gameState: any, emergencyData: any): any => {
  if (!gameState || !emergencyData) return gameState;
  
  try {
    // Проверяем, что экстренное сохранение новее
    const gameStateTime = gameState._lastModified || 
                         (gameState._lastSaved ? new Date(gameState._lastSaved).getTime() : 0);
    
    const emergencyTime = emergencyData.timestamp || 0;
    
    // Если экстренное сохранение старше обычного, игнорируем его
    if (emergencyTime < gameStateTime) {
      console.log('[GameProvider] Экстренное сохранение старше загруженного состояния, игнорируем');
      return gameState;
    }
    
    console.log('[GameProvider] Экстренное сохранение новее загруженного состояния, объединяем данные');
    
    // Объединяем данные - используем данные из экстренного сохранения для критически важных полей
    return {
      ...gameState,
      inventory: {
        ...gameState.inventory,
        snot: emergencyData.snot !== undefined ? emergencyData.snot : gameState.inventory.snot,
        snotCoins: emergencyData.snotCoins !== undefined ? emergencyData.snotCoins : gameState.inventory.snotCoins,
        containerSnot: emergencyData.containerSnot !== undefined ? emergencyData.containerSnot : gameState.inventory.containerSnot
      },
      _emergencyRecovered: true,
      _emergencyRecoveryTime: Date.now()
    };
  } catch (error) {
    console.error('[GameProvider] Ошибка при объединении данных с экстренным сохранением:', error);
    return gameState;
  }
};

export function GameProvider({
  children,
  userId,
  enableAutoSave = true,
  autoSaveInterval = 5000
}: GameProviderProps) {
  // Создаем экземпляр SaveManager
  const saveManagerRef = useRef<SaveManager>(new SaveManager());
  
  // Инициализируем состояние игры с использованием userId из props
  const [state, dispatch] = React.useReducer(
    gameReducer,
    // Используем userId напрямую для создания начального состояния, 
    // но это состояние будет перезаписано при загрузке
    createInitialGameState(userId || '') 
  )

  // Состояние для отслеживания процесса сохранения
  const [isSaving, setIsSaving] = useState<boolean>(false)
  
  // Состояние для отслеживания загрузки данных
  const [isLoading, setIsLoading] = useState<boolean>(false)
  
  // Отслеживаем, было ли выполнено начальное сохранение
  const initialLoadDoneRef = useRef<boolean>(false)

  // Ref для отслеживания активного таймера автосохранения
  const autoSaveTimerRef = useRef<NodeJS.Timeout | null>(null)
  
  // Ref для хранения последнего сохраненного userId
  const lastUserIdRef = useRef<string | undefined>(userId)
  
  // Ref для отслеживания, идет ли уже запрос на загрузку
  const loadRequestInProgressRef = useRef<boolean>(false)
  
  // Создаем ref для хранения предыдущего значения containerSnot
  const prevContainerSnotRef = useRef(state.inventory.containerSnot);

  // Инициализируем SaveManager
  useEffect(() => {
    const initSaveManager = async () => {
      await saveManagerRef.current.initialize();
    };
    
    initSaveManager();
    
    return () => {
      // Очищаем ресурсы при размонтировании компонента
      saveManagerRef.current.cleanup();
    };
  }, []);

  // Загрузка данных пользователя
  const loadUserData = useCallback(async (userId: string) => {
    if (!userId) {
      console.error('[GameProvider] Отсутствует ID пользователя для загрузки данных');
      return false;
    }
    
    console.log('[GameProvider] Starting state load for userId:', userId);
    
    try {
      // Используем SaveManager для загрузки данных
      const loadResult = await saveManagerRef.current.load(userId, {
        storageTypes: [
          StorageType.MEMORY,
          StorageType.LOCAL,
          StorageType.INDEXED_DB,
          StorageType.EMERGENCY,
          StorageType.SERVER
        ],
        fallbackToDefault: true,
        skipIntegrityCheck: false
      });
      
      console.log('[GameProvider] Результат загрузки:', {
        success: loadResult.success,
        source: loadResult.source,
        isNewUser: loadResult.isNewUser,
        wasRepaired: loadResult.wasRepaired
      });
      
      let gameData: GameState;
      
      if (loadResult.isNewUser || !loadResult.data) {
        console.log('[GameProvider] Создание нового состояния для пользователя');
        gameData = createDefaultGameState(userId);
      } else {
        gameData = loadResult.data as unknown as GameState;
        
        if (loadResult.wasRepaired) {
          console.log('[GameProvider] Данные были восстановлены после повреждения');
        }
      }
      
      // Обновляем ресурсы на основе прошедшего времени
      try {
        // Сохраняем предыдущее значение containerSnot для логирования
        const prevContainerSnot = gameData?.inventory?.containerSnot || 0;
        
        console.log('[GameProvider] Состояние перед обновлением на основе времени:', {
          containerSnot: prevContainerSnot,
          fillingSpeed: gameData?.inventory?.fillingSpeed,
          fillingSpeedLevel: gameData?.inventory?.fillingSpeedLevel,
          lastUpdateTimestamp: gameData?.inventory?.lastUpdateTimestamp ? 
            new Date(gameData.inventory.lastUpdateTimestamp).toISOString() : 'отсутствует'
        });
        
        // Проверка и восстановление fillingSpeed на основе уровня
        if (gameData?.inventory?.fillingSpeedLevel) {
          const correctFillingSpeed = getFillingSpeedByLevel(gameData.inventory.fillingSpeedLevel);
          
          if (Math.abs(gameData.inventory.fillingSpeed - correctFillingSpeed) > 0.001) {
            console.log('[GameProvider] Корректировка fillingSpeed:', {
              было: gameData.inventory.fillingSpeed,
              стало: correctFillingSpeed,
              уровень: gameData.inventory.fillingSpeedLevel
            });
            
            gameData.inventory.fillingSpeed = correctFillingSpeed;
          }
        }
        
        // Обновляем ресурсы на основе прошедшего времени
        if (gameData?.inventory?.lastUpdateTimestamp) {
          gameData = updateResourcesBasedOnTimePassed(gameData);
          
          console.log('[GameProvider] Состояние после обновления на основе времени:', {
            было: prevContainerSnot,
            стало: gameData.inventory.containerSnot,
            разница: gameData.inventory.containerSnot - prevContainerSnot
          });
        }
      } catch (updateError) {
        console.error('[GameProvider] Ошибка при обновлении ресурсов:', updateError);
      }
      
      // Обновляем состояние игры
      dispatch({ type: 'SET_GAME_STATE', payload: gameData });
      
      // Сохраняем обновленное состояние
      if (!loadResult.isNewUser) {
        await saveGameState(gameData);
      }
      
      // Отмечаем, что начальная загрузка выполнена
      initialLoadDoneRef.current = true;
      
      return true;
    } catch (error) {
      console.error('[GameProvider] Ошибка при загрузке данных:', error);
      return false;
    }
  }, []);

  // Сохранение состояния игры
  const saveGameState = useCallback(async (currentState: GameState = state, priority = SavePriority.MEDIUM) => {
    if (!userId) {
      console.warn('[GameProvider] Отсутствует userId, сохранение не выполнено');
      return { success: false };
    }
    
    try {
      setIsSaving(true);
      
      // Подготавливаем состояние для сохранения
      const normalizedId = normalizeUserId(userId);
      const preparedState = {
        ...currentState,
        _lastSaved: new Date().toISOString(),
        _userId: normalizedId
      };
      
      // Используем SaveManager для сохранения
      const saveResult = await saveManagerRef.current.save(normalizedId, preparedState as unknown as ExtendedGameState, {
        priority,
        storageTypes: [StorageType.MEMORY, StorageType.LOCAL, StorageType.INDEXED_DB]
      });
      
      if (saveResult.success) {
        console.log('[GameProvider] Состояние успешно сохранено:', {
          source: saveResult.source,
          dataSize: saveResult.dataSize,
          duration: saveResult.duration
        });
      } else {
        console.warn('[GameProvider] Ошибка при сохранении состояния:', saveResult.error);
      }
      
      return saveResult;
    } catch (error) {
      console.error('[GameProvider] Критическая ошибка при сохранении:', error);
      return { success: false, error: String(error) };
    } finally {
      setIsSaving(false);
    }
  }, [userId, state]);

  // Перехватываем действия для автосохранения
  const wrappedDispatch = useCallback((action: Action) => {
    // Сначала обновляем состояние через обычный dispatch
    dispatch(action);
    
    // Затем планируем сохранение, если включено автосохранение
    if (enableAutoSave && userId && initialLoadDoneRef.current) {
      // Очищаем предыдущий таймер автосохранения, если он был
      if (autoSaveTimerRef.current) {
        clearTimeout(autoSaveTimerRef.current);
      }
      
      // Устанавливаем новый таймер
      autoSaveTimerRef.current = setTimeout(() => {
        saveGameState(undefined, SavePriority.LOW);
      }, autoSaveInterval);
    }
  }, [dispatch, enableAutoSave, userId, autoSaveInterval, saveGameState]);

  // Загружаем данные при монтировании или изменении userId
  useEffect(() => {
    if (!userId || loadRequestInProgressRef.current) return;
    
    const normalized = normalizeUserId(userId);
    
    // Если userId изменился, загружаем новые данные
    if (normalized !== lastUserIdRef.current) {
      console.log('[GameProvider] UserId изменился, загружаем новые данные');
      
      loadRequestInProgressRef.current = true;
      setIsLoading(true);
      
      loadUserData(normalized)
        .finally(() => {
          loadRequestInProgressRef.current = false;
          setIsLoading(false);
          lastUserIdRef.current = normalized;
        });
    }
  }, [userId, loadUserData]);

  // Устанавливаем обработчик beforeunload для сохранения перед выходом
  useEffect(() => {
    if (typeof window === 'undefined') return;
    
    // Функция, которая будет вызвана перед выходом
    const handleBeforeUnload = () => {
      if (!userId) return;
      
      // Создаем экстренную резервную копию
      const normalizedId = normalizeUserId(userId);
      saveManagerRef.current.createEmergencyBackup(normalizedId, state as unknown as ExtendedGameState);
    };
    
    // Регистрируем обработчик события
    window.addEventListener('beforeunload', handleBeforeUnload);
    
    // Очищаем обработчик при размонтировании компонента
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [userId, state]);
  
  // Предоставляем состояние и диспетчер через контексты
  return (
    <GameStateContext.Provider value={state}>
      <GameDispatchContext.Provider value={wrappedDispatch}>
        <IsSavingContext.Provider value={isSaving}>
          {children}
        </IsSavingContext.Provider>
      </GameDispatchContext.Provider>
    </GameStateContext.Provider>
  );
}

export default GameProvider 